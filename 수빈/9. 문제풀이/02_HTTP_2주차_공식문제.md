# HTTP 2주차 공식문제

> 기한은 04월 20일 화요일 자정까지!
>
> 일단 보지 않고 생각나는 대로 적어보고, 강의자료를 보면서 부족한 부분을 메꾸는 방식으로 작성하면 좋다.

<br>

### 1. HTTP 메서드 활용

	1. 클라이언트에서 서버로 데이터 전송을 하는 4가지 상황에 대해서 설명하고, 각각의 상황이 일어나는 대표 예시도 함께 설명하라.

- 정적 데이터 조회 : 쿼리 파라미터를 사용하지 않고, 단순하게 GET 요청을 사용해서 조회한다. 주로 이미지나 정적 텍스트 문서를 조회하는 경우가 이에 해당한다.
- 동적 데이터 조회 : 쿼리 파라미터를 사용해서 데이터를 전달한다. 조회를 할 때는 GET 요청을 사용한다. 검색이나 정렬하는 경우에 주로 사용한다.
- HTML Form : GET과 POST 요청만 가능하다. POST 요청 시에는 쿼리 파라미터로 전송하지 않고 HTTP body에 포함해서 전송한다. 주로 회원가입, 상품 주문 등의 경우에 사용한다. 이미지나 영상 등의 파일 업로드를 할 경우에는 Content-Type을 multipart/form-data로 변경해줘야 한다.
- HTTP API : 다양한 HTTP 메서드를 사용할 수 있다. 주로 서버와 서버 사이의 백엔드에서 사용한다. json을 사용해서 전송하는 것이 대부분이다. 

<br>

### 2. HTTP 상태코드

	1. 영구 리다이렉션이 무엇인지 간단히 설명하고, 영구 리다이렉션 코드인 301, 308의 차이점에 대해서 설명하라
	2. 1xx ~ 5xx 의 상태코드가 각각 어떤 처리 상태를 의미하는지 서술하고, 하나의 상태코드에 대해 아는만큼 설명하라 (ex. 401 Unauthorized 상태 코드는 언제 발생하고, 문제를 해결하는 방법은 무엇인지 등)
	3. 일시적 리다이렉션의 예시 중 PRG란 무엇인가? 왜 PRG를 사용하는가?

- 영구 리다이렉션 : 리소스의 URI가 영구적으로 이동되었을 때 사용하는 것이다. 301은 리다이렉트할 때 GET으로 메서드가 변경되면서 본문이 제거될 수 있다. 308은 리다이렉트할 때 요청 메서드와 동일하게 메서드가 유지된다. 따라서 본문을 유지하게 된다.
- 상태코드
  - `1xx` : 요청이 수신되어서 처리중인 경우 반환되는 상태코드이다.
  - `2xx` : 요청이 정상 처리 되었을 때 반환되는 상태코드이다. 200 OK는 주로 정상적으로 응답할 때 가장 많이 받게 되는 상태코드이다. 201 Created는 요청이 성공해서 새로운 리소스가 생성된 것을 의미한다. 204 No Content는 요청은 정상 처리 했지만 돌려보낼 데이터가 없을 때 사용된다.
  - `3xx` : 요청을 정상적으로 완료하기 위해서 추가적인 동작이 필요할 때 반환되는 상태코드이다. 301, 308은 영구 리다이렉션, 302, 307, 303은 일시 리다이렉션을 할 때 반환된다.
  - `4xx` : 클라이언트가 잘못했을 때 반환되는 상태코드이다. 주로 잘못된 문법이나 존재하지 않는 페이지에 접근할 때 발생한다.
  - `5xx` : 서버 오류가 발생했을 때 반환되는 상태코드이다. 서버 오류가 아닌 경우에는 4xx 코드로 반환하는 것이 중요하다.
- PRG : POST, REDIRECT, GET을 의미한다. POST요청이 정상 처리된 이후에 GET으로 REDIRECT 되는 것을 의미한다. 제품 주문을 할 때, POST 요청을 통해서 하는데 요청이 처리된 이후에 새로고침을 하면 주문이 중복되는 문제가 발생할 수 있다. 따라서 이러한 경우에, POST 요청이 정상적으로 처리되었다면 GET으로 결과 화면을 redirect하여 중복 주문을 방지한다. 

<br>

### 3. HTTP 헤더1 - 일반헤더

	1. 쿠키란 무엇인가? 쿠키를 사용하는 경우, 사용하지 않았을 때에 비해 어떤 장점을 가지고 있는가? 쿠키의 생명 주기란 무엇인가?
	2. HTTP 헤더 중 Host는 꼭 들어가야하는 필수 정보이다. Host란 어떤 정보이며 왜 필수 정보인지 예시를 들어 설명하라.

- 쿠키 : HTTP는 Stateless한 특성을 가지고 있기 때문에, 클라이언트와 서버가 요청과 응답을 주고 받은 후에는 연결이 끊어진다. 따라서 클라이언트가 다시 요청하게 되면 서버는 이전 요청을 기억하지 못한다. 하지만 웹 사이트에서는 로그인 등과 같은 상황이 존재한다. 따라서 클라이언트와 서버는 상태를 유지해야할 때 도 있다. 이러한 경우, 상태를 유지해야하는 정보에 대해서 쿠키를 생성하면, 이를 바탕으로 서버와 클라이언트는 상태를 유지할 수 있게 된다. 이러한 쿠키가 유지되는 기간을 생명주기라고 한다. expires나 max-age를 통해서 생명주기를 지정해줄 수 있다. 이 기간이 지나면 자동적으로 쿠키는 삭제된다.
- Host : 요청한 호스트의 정보를 의미한다. 하나의 서버에 여러 도메인이 존재할 때, 호스트 정보가 없다면 어떤 도메인에 요청하는 것인지 판단할 수 없다. 따라서 요청한 호스트의 정보를 알려줘야한다.

<br>

### 4. HTTP 헤더2 - 캐시와 조건부 요청

	1. 확실한 캐시 무효화를 하기 위해 사용하는 지시어 중에는 `no-cache` 와 `must-revalidate`가 있다. 이 둘의 차이점에 기반하여 각각의 기본 동작에 대해서 설명하라.
	2. 캐시 검증 헤더인 Last-Modified와 ETag의 차이를 설명하고, 브라우저를 통해 서버에 요청 시 각각 어떤 조건부 요청 헤더가 사용되는지 설명하라.
	3. 서버에서 기존 데이터를 변경하지 않은 경우, 클라이언트는 캐시를 재사용할 수 있는데, 이를 위해서는 검증 헤더와 조건부 요청이 필요하다. 처음에 캐시가 만들어지는 과정 부터, 검증 헤더와 조건부 요청을 통해서 클라이언트가 캐시를 재사용하는 과정까지 상세하게 작성하라.
- no-cache는 항상 origin 서버에 검증을 받고 캐시를 반환하고, must-revalidate는 캐시 만료 후, 최초로 조회할 때 origin 서버에 검증을 받는다. no-cache는 origin 서버에 접근이 불가할 때, 오류보다는 오래된 데이터라도 보여주는 것을 선택한다. must-revalidate는 origin 서버에 접근이 불가할 때, 항상 오류를 발생시킨다.
- Last-Modified는 데이터의 최종 수정일이, ETag는 고유한 버전 정보가 들어간다. Last-Modified는 내용이 변경되지 않더라도 저장되는 시점이 변경되면 데이터를 재요청하는 불필요한 동작들이 발생할 수 있다. ETag는 임의의 버전 정보가 동일하다면, 데이터를 재요청하는 과정을 생략한다. 조건부 요청으로 Last-Modified는 If-Modified-Since를, ETag는 If-None-Match를 사용한다.
- 캐시 과정
  1. 클라이언트에서 서버로 데이터를 요청한다.
  2. 서버는 Last-Modified 또는 ETag 중 하나의 검증헤더와 데이터를 담아서 응답 메시지를 클라이언트에게 보낸다.
  3. 클라이언트는 해당 데이터와 검증헤더를 캐시에 저장한다. 
  4. 캐시가 만료되었다면, 검증헤더를 활용해 조건부 요청으로 서버에게 전송한다.
  5. 서버는 이를 판단하여 조건부 요청의 진위 여부를 확인한다. 서버의 데이터와 클라이언트의 캐시가 다른지에 대해서 확인한다.
  6. 데이터와 캐시가 같다면 304 상태코드를 헤더에 포함하고, body없이 클라이언트로 보낸다 / 다르다면 200 상태코드를 헤더에 포함하고, body에 새로운 데이터와 함께 전송한다.
  7. 클라이언트는 이를 확인하고 기존 캐시에 있는 데이터를 사용한다. / 메시지를 확인하고 새로운 데이터를 이용해서 캐시를 갱신한다.

