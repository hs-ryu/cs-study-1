# 운영체제 9주차 공식문제

> 06월 27일 화요일 자정까지

<br>

1. 페이지 부재(Page Fault)란 무엇인지 정의하고, 페이지 부재를 처리하는 과정을 서술하라.
   - 운영체제는 물리 메모리를 효율적으로 사용하기 위해 프로세스의 모든 페이지를 물리메모리에 로드하지 않기 때문에 물리메모리에 부재할 수 있는데, 이를 Page Fault라고 한다. Page Fault가 발생하게 되면, 헤당 페이지를 가상 메모리에서 찾아야하는데, 운영체제는 페이지 테이블로써 가상 메모리를 관리하므로 다음과 같은 순서에 따라 Page Fault를 처리하게 된다.
     1. CPU는 물리 메모리를 확인하여 페이지가 없으면 운영체제에 알린다.
     2. 운영체제는 CPU의 동작을 잠시 멈춘다
     3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.
     4. Page Fault이면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾는다.
     5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
     6. 중단된 CPU를 다시 시작한다.
2. LRU 알고리즘과 LFU 알고리즘은 각각 어떤 자료구조를 통해 구현하는 것이 좋은가? 그 이유도 함께 작성하라.

   - LRU알고리즘은 Least Recently Algorithm으로써 가장 오래 전에 참조된 페이지(가장 오랫동안 사용하지 않은 페이지)를 지운다. 따라서 Counter나 Stack을 이용하여 구현하는것이 좋다. 스택을 사용하게 되면 가장 바닥에 있는 페이지를 교체한다고 하면, 스택 안에 존재하는 페이지에 대해 재참조가 발생하는 경우 스택 내부에서 가장 위로 이동이 필요하다.
   - LFU는 Least Frequently Used Algorithm으로써 참조 횟수가 가장 적은 페이지를 지운다. 
3. Frame의 크기가 `4`이고, Reference string이 `1,2,3,4,1,2,5,1,2,3,4,5`가 주어졌을때,
   LRU 알고리즘과 FIFO 알고리즘으로 페이지 부재가 몇번 일어나는지 각 알고리즘의 개념과 함께 설명하라.
   - LRU알고리즘은 가장 오래 전에 참조된 페이지(가장 오랫동안 사용하지 않은 페이지)를 지운다. 따라서 아래 그림과 같은 순서대로 Frame에 페이지가 저장되고 총 4번의 Page Fault가 발생한다.
     - 1
     - 1,2
     - 1,2,3
     - 1,2,3,4
     - 1,2,3,4
     - 1,2,3,4
     - 1,2,5,4 <- page fault
     - 1,2,5,4
     - 1,2,5,4
     - 1,2,5,3 <- page fault
     - 1,2,4,3 <- page fault
     - 5,2,4,3 <- page fault
   - FIFO 알고리즘은 First In First Out 알고리즘으로 먼저 참조된 페이지를 지운다. 따라서 아래 그림과 같은 순서대로 Frame에 페이지가 저장되고 총 6번의 Page Fault가 발생한다.
     - 1
     - 1,2
     - 1,2,3
     - 1,2,3,4
     - 1,2,3,4
     - 1,2,3,4
     - 5,2,3,4 <- page fault
     - 5,1,3,4 <- page fault
     - 5,1,2,4 <- page fault
     - 5,1,2,3 <- page fault 
     - 4,1,2,3 <- page fault
     - 4,5,2,3 <- page fault
4. 스레싱(Thrashing)이란 무엇인지 정의하고, 스레싱이 발생하는 과정을 서술하라.
   - 프레임을 충분히 할당 받지 못한 프로세스는 Page Fault가 발생하고, 이때 replace가 발생해도 활발하게 사용되는 페이지들이 계속 들어온다면 계속해서 page Fault가 발생할 수 있고, Page Fault가 과도하게 발생하는 것을 스레싱이라고 한다. 
   - 메모리에 동시에 올라가 있는 프로세스의 수가 높아지면 어느 정도까지는 CPU 이용률이 오르지만, 한계치를 넘으면 스레싱이 발생하고 오히려 CPU 이용률이 급감하게 된다. 운영체제는 CPU 이용률을 감시하여 CPU 이용률이 너무 낮아지면 새로운 프로세스를 시스템에 추가하는 작업을 하게 되는데 이때 전역 페이지 교체 알고리즘을 사용하여 어떤 프로세스의 페이지인지에 대한 고려 없이 교체를 수행하게 된다. 프로세스들이 페이징 장치를 기다리는 동안 CPU 이용률은 떨어지게 되고, CPU 스케줄러는 이용률이 떨어지는 것을 보고 높이기 위해 새로운 프로세스를 추가하게 되는데, 이는 더 많은 Page fault를 야기하게되고, 스레싱이 발생하게된다.

