# HTTP 2주차 공식문제

> 기한은 04월 20일 화요일 자정까지!
>
> 일단 보지 않고 생각나는 대로 적어보고, 강의자료를 보면서 부족한 부분을 메꾸는 방식으로 작성하면 좋다.

<br>

### 1. HTTP 메서드 활용

 1. 클라이언트에서 서버로 데이터 전송을 하는 4가지 상황에 대해서 설명하고, 각각의 상황이 일어나는 대표 예시도 함께 설명하라.

- 클라이언트에서 서버로 어떤 요청을 보낼 때 데이터가 전송되는 것이라고 할 수 있다. 먼저, 어떤 게시물을 클릭하거나 했을때 발생하는 데이터 조회가 있다. 데이터 조회는 정적 데이터 조회와 동적 데이터 조회로 나눌 수 있는데, 정적 데이터 조회는 이미지나, 어떤 텍스트 문서들을 조회하는 것이다. 동적 데이터 조회는 필터를 사용한 검색이나, 정렬 등을 통해 얻어지는 데이터가 달라지는 것을 조회하는 것이다.

    어떤 요청을 보낼때, 클라이언트의 데이터를 함께 보내야 하는 경우도 존재하는데, HTML Form을 통해 전송하거나 HTTP API를 통해 전송하는 경우가 있다. 회원가입을 할때나 상품을 주문하거나 할 때 Form에 입력한 정보들을 전송하는 것이 HTML Form을 통해 전송하는 경우이다. 서버에서 서버로 데이터를 전송(서버끼리 통신; 백엔드 시스템 통신)하는 경우에는 API를 통해 데이터를 전송한다.

<br>

### 2. HTTP 상태코드

	1. 영구 리다이렉션이 무엇인지 간단히 설명하고, 영구 리다이렉션 코드인 301, 308의 차이점에 대해서 설명하라
	2. 1xx ~ 5xx 의 상태코드가 각각 어떤 처리 상태를 의미하는지 서술하고, 하나의 상태코드에 대해 아는만큼 설명하라 (ex. 401 Unauthorized 상태 코드는 언제 발생하고, 문제를 해결하는 방법은 무엇인지 등)
	3. 일시적 리다이렉션의 예시 중 PRG란 무엇인가? 왜 PRG를 사용하는가?

1. 리다이렉트란 웹 브라우저가 300번대의 응답 결과에 Location 헤더가 있으면 그 Location 위치로 자동으로 이동하는것을 말하는데, 영구 리다이렉션은 특정 리소스의 URI가 영구적으로 이동하는 것이다. 예를 들어 이벤트 페이지가 있을때, 만료된 후 나중에 새로운 이벤트 페이지가 만들어 졌을때 기존 이벤트의 url을 입력하면 새로 만들어진  이벤트 페이지로 리다이렉션 시켜줄 수 있다. 301 코드는 Moved Permanently 코드로, 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다(꼭 제거되는것은 아님). 308 코드는 Permanent Redirect 코드로, 301코드와 기능적으론 동일하지만 리다이렉트시 요청 메서드와 본문이 유지된다는 차이가 있다.

2. 100번대 상태코드는 요청이 수신되어 처리 중, 200번대 상태코드는 요청이 정상적으로 처리됨, 300번대 상태코드는 요청을 완료하기 위해 추가적인 행동이 필요함, 400번대 상태코드는 클라이언트의 오류(잘못된 문법 등)로 서버가 요청을 수행할 수 없음, 500번대 상태코드는 서버 오류로 서버가 정상 요청을 처리하지 못했다는 것을 의미한다. 503 상태코드에 대해서 설명해 보면, Service Unavailable을 의미하는 코드로 서비스를 이용할 수 없다는 뜻이다. 서버가 일시적인 과부하나 예정된 작업으로 인해 클라이언트의 요청을 처리할 수 없다는 의미이다. 이때, 서버는 상태메시지를 보내면서 Retry-After 헤더 필드로 언제 복구되는지에 대한 정보를 전달할 수 있지만, 실제로 서버복구에 걸리는 시간을 정확하게 계산할 수 없기 때문에 서버 입장에서는 선택해야할 옵션임.
3. PRG는 Post-Redircet-Get의 약자로써, 일시적인 리다이렉션의 예시 중 하나이다. 말 그대로 Post 요청의 Redirection은 Get으로 하겠다는 것인데, 만약 상품을 주문한다고 했을때 주문 후(Post 요청) 실수로 새로고침을 눌렀을 때(Redirection) 다시 주문(Post)되면 고객 입장에서는 난처할 수 밖에 없다. 따라서 이런 중복되는 경우를 없애기 위해 Post 요청 후 Redirection은 GET 요청으로 한다는 것이 PRG이다. PRG를 사용하면 언급한 예시와 같이 사용자의 실수 등으로 인한 오류가 적어지고 사용성이 좋다. 

<br>

### 3. HTTP 헤더1 - 일반헤더

	1. 쿠키란 무엇인가? 쿠키를 사용하는 경우, 사용하지 않았을 때에 비해 어떤 장점을 가지고 있는가? 쿠키의 생명 주기란 무엇인가?
	2. HTTP 헤더 중 Host는 꼭 들어가야하는 필수 정보이다. Host란 어떤 정보이며 왜 필수 정보인지 예시를 들어 설명하라.

1. 쿠키란 클라이언트들의 효율적이고 안전한 웹 사용을 보장하기 위해 웹사이트에 널리 사용되고 있는 작은 텍스트 파일이라고 할 수 있다. 웹 사이트 접속시 클라이언트의 개인 장치에 다운로드 되고, 브라우저에 저장되는데, 웹사이트는 쿠키를 통해 클라이언트의 설정과 과거 이용 내역에 대한 일부 데이터를 저장한다. 서버측으로 부터 로그인을 요구받은 경우, 쿠키를 쓰지 않으면 서버측으로 로그인을 했다는 것을 알리기 위해 모든 요청에 계속해서 사용자 정보를 넘겨줘야한다(HTTP는 무상태 프로토콜이기 때문에 상태 정보를 가지고 있지 않고, 응답을 하고 나면 연결을 끊기 때문). 사용자 정보를 계속해서 넘겨주면 보안적인 부분에서도 위험하고, 개발하는 개발자 측면에서도 비효율 적이다. 따라서 이런 로그인 정보를 쿠키에 담아 웹 브라우저에 보내면, 웹 브라우저는 유저 정보를 저장하고 있어(만료시까지) 사용자 정보를 계속해서 받을 필요가 없어진다.

2. Host는 request할때 사용하는 정보로써 정확히 어떤 도메인으로 갈 것인지 표시하는 정보이다. 서버는 가상 호스트를 통해 여러 도메인을 한번에 처리할 수 있고, 실제 애플리케이션이 여러개 구동될 수도 있다. 따라서 만약 하나의 서버가 여러개의 도메인을 처리하는 경우에 정확하게 어디로 요청을 보낼것인지에 Host 정보가 필요하다.

<br>

### 4. HTTP 헤더2 - 캐시와 조건부 요청

	1. 확실한 캐시 무효화를 하기 위해 사용하는 지시어 중에는 `no-cache` 와 `must-revalidate`가 있다. 이 둘의 차이점에 기반하여 각각의 기본 동작에 대해서 설명하라.
	2. 캐시 검증 헤더인 Last-Modified와 ETag의 차이를 설명하고, 브라우저를 통해 서버에 요청 시 각각 어떤 조건부 요청 헤더가 사용되는지 설명하라.
	3. 서버에서 기존 데이터를 변경하지 않은 경우, 클라이언트는 캐시를 재사용할 수 있는데, 이를 위해서는 검증 헤더와 조건부 요청이 필요하다. 처음에 캐시가 만들어지는 과정 부터, 검증 헤더와 조건부 요청을 통해서 클라이언트가 캐시를 재사용하는 과정까지 상세하게 작성하라.
1. 간단하게 설명하면, no-cache는 캐시 데이터를 사용하기 전에 항상 원 서버에 검증하고 한다는 것이고, must-revalidate는 만료된 캐시만 서버에 확인을 받도록 하는 것이다. 둘의 큰 차이는 원 서버 접근 실패시 오류가 발생하는가 발생하지 않는가의 차이가 있는데, no-cache는 원 서버 접근이 불가능 해도 오류가 발생하지 않기 때문에 (200 상태 응답) 순간 네트워크 단절 등으로 원 서버 접근이 불가능 할때 오류보다는 오래된 데이터라도 보여주는게 낫다고 판단될 때 사용될 수 있고, must-revalidate는 원 서버 접근이 불가능 하면 항상 504 오류가 발생하기 때문에 중요한 정보 처리가 필요한 경우 필수적이다.
2. Last-Modified와 ETag는 검증 헤더에서 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터이다. Last-Modified는 최종적으로 수정된 날짜 기반의 정보가 들어가고, ETag는 임의의 고유한 버전 정보가 들어간다. 이 둘이 어떻게 다를까? Last-Modified는 데이터가 스페이스, 주석과 같이 데이터 자체에 큰 영향이 없는 변경이 일어나도 수정된 날짜가 변경되었기 때문에 캐시에 새로 저장되어야 한다. 하지만 ETag는 날짜가 아닌 버전으로 처리되기 때문에 수정된 결과가 수정 전과 같은 상황처럼 버전이 달라지지 않는 경우에는 캐시에 새로 저장하지 않아도 된다. 이 둘은 각각 캐시에 데이터와 함께 저장되고, 이후에 클라이언트에서 서버로 요청을 보낼 때 If-Modified-Since 헤더와 If-None-Match 헤더를 통해 캐시 데이터가 유효한지 검증한다. 

3. 
   1. 클라이언트 -> 서버로 데이터 요청
   2. 서버 -> 클라이언트로 응답을 보내는데, 데이터와 함께 데이터가 마지막에 수정된 시간을 넣어서 응답
   3. 클라이언트는  캐시에 저장할 때, 데이터 최종 수정일을 함께 기록하여 저장.
   4. 캐시가 만료되어 다시 요청을 보내야 할 때, 조건부 헤더를 통해 최종 수정일을 물어보고, 같으면 캐시에 있는 값을 재사용한다.